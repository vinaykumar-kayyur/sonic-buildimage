#!/usr/bin/env python3

import time
import signal
from enum import Enum, unique
from swsscommon import swsscommon
from sonic_py_common.logger import Logger 

SYSLOG_IDENTIFIER = 'non_persistent_acl_mgrd'
APP_ACL_RULE_TABLE_NAME = "ACL_RULE_TABLE"
STATE_NON_PERSISTENT_ACL_RULE_TABLE_NAME = "NON_PERSISTENT_ACL_RULE_TABLE"

non_persistent_acl_checker = None

logger = Logger(SYSLOG_IDENTIFIER)
logger.set_min_log_priority_info()

@unique
class ACLRuleStatus(Enum):
    REMOVE_PENDING = 0
    ACTIVE = 1


class NonPersistentACLChecker(object):
    """
    Class which subscribes notification of changes in ACL rule table of APP DB.
    The state machine of an ACL rule is:
    |Active| - 180s by default -> |Active but Remove pending| - 180s by default -> |Removed|
        |                                                              |
        \<-------------------------------------------------------------/
                             SET op
    """
    
    
    def __init__(self, interval_in_second=180):
        # Open a handle to the Application database
        self.appl_db = swsscommon.DBConnector("APPL_DB", 0, False)

        # Open a handle to the State database
        self.state_db = swsscommon.DBConnector("STATE_DB", 0, False)
        
        # By default, the program will check ACL rule every 180s
        self.interval_in_second = interval_in_second
        self.acl_rule = {}


    def start_working(self):
        """
        Main loop for checking ACL rules
        """
        self.working = True
        logger.log_info("Non-persistent ACL manager starts working")

        # Set select timeout to 5 seconds
        SELECT_TIMEOUT_MS = 1000 * 5

        # Subscribe to ACL Rule table notifications in the App DB
        sel = swsscommon.Select()
        sst_appdb = swsscommon.SubscriberStateTable(self.appl_db, APP_ACL_RULE_TABLE_NAME)
        sel.addSelectable(sst_appdb)

        last_flush = int(time.time())

        while self.working:
            (state, selectableObj) = sel.select(SELECT_TIMEOUT_MS)

            if state == swsscommon.Select.OBJECT:
                if selectableObj.getFd() == sst_appdb.getFd():
                    (key, op, fvp) = sst_appdb.pop()
                    if op == 'SET':
                        self.process_acl_rule_table_event(key, op, fvp)
                else:
                    self.log_error("Got unexpected selectable object")

            if int(time.time()) - last_flush > self.interval_in_second:
                self.process_acl_rule_flush()
                last_flush = int(time.time())


    def get_acl_rule_status_string(self, value):
        if value == ACLRuleStatus.REMOVE_PENDING:
            return "REMOVE_PENDING"
        elif value == ACLRuleStatus.ACTIVE:
            return "ACTIVE"
        else:
            return "UNKNOWN"


    def process_acl_rule_table_event(self, key, op, fvp):
        """
        Process APP DB ACL rule table SET op event
        """
        logger.log_info('Process APP DB ACL rule table event: {} {} {}'.format(key,op,fvp))

        # 1 = Active, 0 = Remove pending
        self.acl_rule[key] = ACLRuleStatus.ACTIVE

        # Save above status to STATE DB
        ps = swsscommon.ProducerStateTable(self.state_db, STATE_NON_PERSISTENT_ACL_RULE_TABLE_NAME)
        fvs = swsscommon.FieldValuePairs([('Status', self.get_acl_rule_status_string(ACLRuleStatus.ACTIVE))])
        ps.set(key, fvs)


    def process_acl_rule_flush(self):
        """
        Flush APP DB "Remove pending" ACL rules
        Change "active" ACL rules to "Remove pending" status.
        """
        for key in list(self.acl_rule):
            if self.acl_rule[key] == ACLRuleStatus.REMOVE_PENDING:
                # Remove "Remove_pending" ACL rules in APP DB
                del self.acl_rule[key]
                ps = swsscommon.ProducerStateTable(self.appl_db, APP_ACL_RULE_TABLE_NAME)
                ps._del(key)

                # Remove status in STATE DB
                ps = swsscommon.ProducerStateTable(self.state_db, STATE_NON_PERSISTENT_ACL_RULE_TABLE_NAME)
                ps._del(key)

                logger.log_info("Remove non-persistent ACL from APPL_DB: {}".format(key))
            elif self.acl_rule[key] == ACLRuleStatus.ACTIVE:
                # Change "Active" ACL rules to "Remove pending" status
                self.acl_rule[key] = ACLRuleStatus.REMOVE_PENDING

                # Change status in STATE DB
                ps = swsscommon.ProducerStateTable(self.state_db, STATE_NON_PERSISTENT_ACL_RULE_TABLE_NAME)
                fvs = swsscommon.FieldValuePairs([('Status', 
                                        self.get_acl_rule_status_string(ACLRuleStatus.REMOVE_PENDING))])
                ps.set(key, fvs)

                logger.log_info("Set to remove-pending for non-persistent ACL in APPL_DB: {}".format(key))


    def stop_working(self):
        """
        Stop main loop.
        """
        self.working = False
        logger.log_info("Non-persistent ACL manager is going to quit")

# ============================= Functions =============================


def sig_term_handler(signal, frame):
    """
    A signal handler to ensure the working is shutdown gracefully
    """
    global non_persistent_acl_checker
    if non_persistent_acl_checker:
        non_persistent_acl_checker.stop_working()


def main():
    signal.signal(signal.SIGTERM, sig_term_handler)
    
    # Start working
    global non_persistent_acl_checker
    non_persistent_acl_checker = NonPersistentACLChecker()
    non_persistent_acl_checker.start_working()


if __name__ == "__main__":
    main()

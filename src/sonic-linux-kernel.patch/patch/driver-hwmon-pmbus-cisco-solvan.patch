From bf92a84ab2654906b8151db0687e54a7dea7668c Mon Sep 17 00:00:00 2001

From: jiahwang <jiahwang@cisco.com>

Subject: [PATCH] Add pmbus_cisco driver for Cisco PSU including solvang and DC
 PSU. Skip checking STATUS_CML register, otherwise some PSU may not be probed.
 Don't add READ_VCAP to sensor group, we want hwmon/in2 under sysfs pointing
 to VOUT regardless if the PSU has VCAP function or not.  Don't add FAN 3 and
 FAN 4 to sensor group, solvang PSU might report the non existing function.

Signed-off-by: jiahwang <jiahwang@cisco.com>
---
 drivers/hwmon/pmbus/Kconfig       |   10 ++
 drivers/hwmon/pmbus/Makefile      |    1 
 drivers/hwmon/pmbus/pmbus_cisco.c |  243 +++++++++++++++++++++++++++++++++++++
 3 files changed, 254 insertions(+)
 create mode 100644 drivers/hwmon/pmbus/pmbus_cisco.c

diff --git a/drivers/hwmon/pmbus/Kconfig b/drivers/hwmon/pmbus/Kconfig
index c3e72c6e7..9351c3677 100644
--- a/drivers/hwmon/pmbus/Kconfig
+++ b/drivers/hwmon/pmbus/Kconfig
@@ -237,4 +237,14 @@ config SENSORS_CISCO_N2200
 	  This driver can also be built as a module. If so, the module will
 	  be called cisco_n2200
 
+config SENSORS_CISCO_PMBUS
+	tristate "Cisco PMBUS PSU and compatibles"
+	default n
+	help
+	  If you say yes here you get hardware monitoring support for Cisco PMBUS
+	  PSU (For some NEXUS N3K/N9K switches).
+
+	  This driver can also be built as a module. If so, the module will
+	  be called pmbus_cisco
+
 endif # PMBUS
diff --git a/drivers/hwmon/pmbus/Makefile b/drivers/hwmon/pmbus/Makefile
index df9119c0d..9cdf133bf 100644
--- a/drivers/hwmon/pmbus/Makefile
+++ b/drivers/hwmon/pmbus/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_SENSORS_XDPE122)	+= xdpe12284.o
 obj-$(CONFIG_SENSORS_ZL6100)	+= zl6100.o
 obj-$(CONFIG_SENSORS_DPS1900)	+= dps1900.o
 obj-$(CONFIG_SENSORS_CISCO_N2200) += cisco_n2200.o
+obj-$(CONFIG_SENSORS_CISCO_PMBUS) += pmbus_cisco.o
diff --git a/drivers/hwmon/pmbus/pmbus_cisco.c b/drivers/hwmon/pmbus/pmbus_cisco.c
new file mode 100644
index 000000000..561b1aa7f
--- /dev/null
+++ b/drivers/hwmon/pmbus/pmbus_cisco.c
@@ -0,0 +1,244 @@
+/*
+ * Hardware monitoring driver for Cisco PMBus PSU devices,
+ * including Solvang PSU and DC PSU.
+ *
+ * Based on Guenter Roeck's pmbus.c.
+ * Changes are made to skip READ_VCAP, FAN 3, FAN 4 and STATUS_CML registers
+ * on Cisco Solvang PSU
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/i2c.h>
+#include <linux/pmbus.h>
+#include "pmbus.h"
+
+static const struct i2c_device_id pmbus_cisco_id[];
+
+/*
+ * Find sensor groups and status registers on each page.
+ */
+static void pmbus_cisco_find_sensor_groups(struct i2c_client *client,
+				     struct pmbus_driver_info *info)
+{
+	int page;
+
+	/* Sensors detected on page 0 only */
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_VIN))
+		info->func[0] |= PMBUS_HAVE_VIN;
+	/*
+	 * Not all PSU have VCAP, detecting VCAP may cause VOUT to be
+	 * hwmon/in3 if VCAP is present, or hwmon/in2 if VCAP is absent.
+	 */
+#if 0
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_VCAP))
+		info->func[0] |= PMBUS_HAVE_VCAP;
+#endif
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_IIN))
+		info->func[0] |= PMBUS_HAVE_IIN;
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_PIN))
+		info->func[0] |= PMBUS_HAVE_PIN;
+	/* Don't care status */
+	if (info->func[0]
+	    && pmbus_check_byte_register(client, 0, PMBUS_STATUS_INPUT))
+		info->func[0] |= PMBUS_HAVE_STATUS_INPUT;
+	if (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_12) &&
+	    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_1)) {
+		info->func[0] |= PMBUS_HAVE_FAN12;
+		if (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_12))
+			info->func[0] |= PMBUS_HAVE_STATUS_FAN12;
+	}
+	/* Solvang PSU does not have FAN 3 or 4 */
+#if 0
+	if (pmbus_check_byte_register(client, 0, PMBUS_FAN_CONFIG_34) &&
+	    pmbus_check_word_register(client, 0, PMBUS_READ_FAN_SPEED_3)) {
+		info->func[0] |= PMBUS_HAVE_FAN34;
+		if (pmbus_check_byte_register(client, 0, PMBUS_STATUS_FAN_34))
+			info->func[0] |= PMBUS_HAVE_STATUS_FAN34;
+	}
+#endif
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_1))
+		info->func[0] |= PMBUS_HAVE_TEMP;
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_2))
+		info->func[0] |= PMBUS_HAVE_TEMP2;
+	if (pmbus_check_word_register(client, 0, PMBUS_READ_TEMPERATURE_3))
+		info->func[0] |= PMBUS_HAVE_TEMP3;
+	if (info->func[0] & (PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2
+			     | PMBUS_HAVE_TEMP3)
+	    && pmbus_check_byte_register(client, 0,
+					 PMBUS_STATUS_TEMPERATURE))
+			info->func[0] |= PMBUS_HAVE_STATUS_TEMP;
+
+	/* Sensors detected on all pages */
+	for (page = 0; page < info->pages; page++) {
+		if (pmbus_check_word_register(client, page, PMBUS_READ_VOUT)) {
+			info->func[page] |= PMBUS_HAVE_VOUT;
+			if (pmbus_check_byte_register(client, page,
+						      PMBUS_STATUS_VOUT))
+				info->func[page] |= PMBUS_HAVE_STATUS_VOUT;
+		}
+		if (pmbus_check_word_register(client, page, PMBUS_READ_IOUT)) {
+			info->func[page] |= PMBUS_HAVE_IOUT;
+			if (pmbus_check_byte_register(client, 0,
+						      PMBUS_STATUS_IOUT))
+				info->func[page] |= PMBUS_HAVE_STATUS_IOUT;
+		}
+		if (pmbus_check_word_register(client, page, PMBUS_READ_POUT))
+			info->func[page] |= PMBUS_HAVE_POUT;
+	}
+}
+
+
+/*
+ * Identify chip parameters.
+ */
+static int pmbus_cisco_identify(struct i2c_client *client,
+			  struct pmbus_driver_info *info)
+{
+	int ret = 0;
+
+	if (!info->pages) {
+		/*
+		 * Check if the PAGE command is supported. If it is,
+		 * keep setting the page number until it fails or until the
+		 * maximum number of pages has been reached. Assume that
+		 * this is the number of pages supported by the chip.
+		 */
+		if (pmbus_check_byte_register(client, 0, PMBUS_PAGE)) {
+			int page;
+
+			for (page = 1; page < PMBUS_PAGES; page++) {
+				if (pmbus_set_page(client, page, 0xff) < 0)
+					break;
+			}
+			pmbus_set_page(client, 0, 0xff);
+			info->pages = page;
+		} else {
+			info->pages = 1;
+		}
+	}
+
+	if (pmbus_check_byte_register(client, 0, PMBUS_VOUT_MODE)) {
+		int vout_mode;
+
+		vout_mode = pmbus_read_byte_data(client, 0, PMBUS_VOUT_MODE);
+		if (vout_mode >= 0 && vout_mode != 0xff) {
+			switch (vout_mode >> 5) {
+			case 0:
+				break;
+			case 1:
+				info->format[PSC_VOLTAGE_OUT] = vid;
+				break;
+			case 2:
+				info->format[PSC_VOLTAGE_OUT] = direct;
+				break;
+			default:
+				ret = -ENODEV;
+				goto abort;
+			}
+		}
+	}
+
+	/*
+	 * We should check if the COEFFICIENTS register is supported.
+	 * If it is, and the chip is configured for direct mode, we can read
+	 * the coefficients from the chip, one set per group of sensor
+	 * registers.
+	 *
+	 * To do this, we will need access to a chip which actually supports the
+	 * COEFFICIENTS command, since the command is too complex to implement
+	 * without testing it. Until then, abort if a chip configured for direct
+	 * mode was detected.
+	 */
+	if (info->format[PSC_VOLTAGE_OUT] == direct) {
+		ret = -ENODEV;
+		goto abort;
+	}
+
+	/* Try to find sensor groups  */
+	pmbus_cisco_find_sensor_groups(client, info);
+
+abort:
+	return ret;
+}
+
+static int pmbus_cisco_probe(struct i2c_client *client)
+{
+	struct pmbus_driver_info *info;
+	struct device *dev = &client->dev;
+	struct pmbus_platform_data *pdata = dev_get_platdata(dev);
+	int ret;
+
+	/* Solvang PSU does not have STATUS_CML register */
+	pdata = devm_kzalloc(&client->dev, sizeof(struct pmbus_platform_data),
+			    GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+	pdata->flags |= PMBUS_SKIP_STATUS_CHECK;
+	dev->platform_data = pdata;
+
+	info = devm_kzalloc(&client->dev, sizeof(struct pmbus_driver_info),
+			    GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->pages = i2c_match_id(pmbus_cisco_id, client)->driver_data;
+	info->identify = pmbus_cisco_identify;
+
+	ret = pmbus_do_probe(client, info);
+
+	return ret;
+}
+
+static int pmbus_cisco_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+
+	dev->platform_data = NULL;
+
+	return 0;
+}
+
+/*
+ * Use driver_data to set the number of pages supported by the chip.
+ */
+static const struct i2c_device_id pmbus_cisco_id[] = {
+	{"pmbus_cisco", 1},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, pmbus_cisco_id);
+
+/* This is the driver that will be inserted */
+static struct i2c_driver pmbus_cisco_driver = {
+	.driver = {
+		   .name = "pmbus_cisco",
+		   },
+	.probe_new = pmbus_cisco_probe,
+	.remove = pmbus_cisco_remove,
+	.id_table = pmbus_cisco_id,
+};
+
+module_i2c_driver(pmbus_cisco_driver);
+
+MODULE_AUTHOR("Jiahua Wang");
+MODULE_DESCRIPTION("Cisco PSU PMBus driver");
+MODULE_LICENSE("GPL");

/*
 * Copyright 2024 Broadcom Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#ifndef _APP_TIMER_H
#define _APP_TIMER_H

//#include "pacinfra_common.h"
#include "sll_api.h"
/*********************  Datatype Typedefs  ***********************/
typedef void*  APP_TMR_HNDL_t;     /* Handle to reference a timer. This will
                                        be generated by the library whenever a
                                        new timer is added and the application
                                        MUST use this handle to reference this
                                        timer within the library */
typedef void*  APP_TMR_CTRL_BLK_t; /* Handle for a timer module instance. This
                                        will be generated by the library for
                                        every instantiation of the timer module
                                        and the application MUST use this handle
                                        to reference a timer module instance
                                        for various timer operations, eg. TimerAdd,
                                        TimerDelete, etc */

typedef enum
{
   APP_TMR_INVALID = 0,
   APP_TMR_1MSEC   = 1,    /* Timer tick granularity of 1 millisecond    */
   APP_TMR_10MSEC  = 10,   /* Timer tick granularity of 10 milliseconds  */
   APP_TMR_100MSEC = 100,  /* Timer tick granularity of 100 milliseconds */
   APP_TMR_1SEC    = 1000  /* Timer tick granularity of 1 second         */
}  APP_TMR_GRAN_TYPE_t;

/*********************  Function Typedefs  ***********************/
/*********************************************************************
*
* @purpose  To dispatch the base timer tick to the application
*
* @param    timerCtrlBlk @b{(input)}Control Block of the timer module instance with which
*                                   the timer tick is associated with
* @param    pParam       @b{(input)}Opaque user parameter that was registered with the library
*                                   during the timer module instantiation
*
* @returns  None
*
* @notes    This dispatcher funcion MUST be provided by the application during
*           a Timer Module instantiation. Every Timer Module instance will be
*           associated with one system level timer (eg.osapiTimer). The Timer
*           library would request the application to service the associated
*           system timer tick using this function.
*           CAUTION : Application MUST NOT do extensive processing in this
*                     function's context, but rather off-load the processing to
*                     its own task.
*           The application from within its own context should invoke appTimerProcess()
*           call to actually service the system timer tick for the given
*           timer module instance.
*
* @end
*
*********************************************************************/
typedef void (* app_tmr_dispatcher_fn)( APP_TMR_CTRL_BLK_t timerCtrlBlk, void *pParam);

/*********************************************************************
*
* @purpose  To service a timer expiry
*
* @param    *pParam @b{(input)}The parameter registered with the timer library when the
*                              timer was added/created/updated.
*
* @returns  None
*
* @notes    This function MUST be provided by the application whenever an application
*           timer is added/created/updated. The library (while processing appTmrProcess())
*           would invoke this function whenever the associated timer expires.
*           This function will be invoked along with the parameter that was
*           registered along with the function.
*
* @end
*
*********************************************************************/
typedef void (* app_tmr_fn)(void *pParam);

/*********************  Function Definitions ***********************/
/*********************************************************************
*
* @purpose  Initialize/Instantiate an Application Timer Module
*
* @param    compId       @b{(input)}Component ID of the owner
* @param    dispatchFn   @b{(input)}Function dispatcher that would off-load processing
*                                   to the application context
* @param    pParam       @b{(input)}Opaque user parameter that is to be returned in the tick
*                                   dispatcher for the application's use
* @param    timerType    @b{(input)}Granularity of the timer tick (applies to all timers
*                                   associated with this instance)
* @param    buffPoolID   @b{(input)}Buffer Pool ID to be associated with this instance
*
* @returns  appTmrCtrlBlk Opaque Control Block for the timer module instance, if successful
* @returns   NULLPTR    If timer module instantiation failed
*
* @notes    None
*
* @end
*
*********************************************************************/
extern  APP_TMR_CTRL_BLK_t appTimerInit( COMPONENT_IDS_t       compId,
                                           app_tmr_dispatcher_fn dispatchFn,
                                          void                     *pParam,
                                           APP_TMR_GRAN_TYPE_t   timerType,
                                          uint32                buffPoolID);

/*********************************************************************
*
* @purpose  De/Un-Initialize/Instantiate an Application Timer Module
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance that is to be destroyed
*
* @returns   SUCCESS  If operation was successful
* @returns   FAILURE  If operation failed
*
* @notes    The operation would clean-out any and all timers already in the
*           instance and also free-up any resources (memory,etc).
*
* @end
*
*********************************************************************/
extern RC_t appTimerDeInit( APP_TMR_CTRL_BLK_t timerCtrlBlk);

/*********************************************************************
*
* @purpose  Add/Create an Application Timer
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance on which the new timer is being added to
* @param    pFunc        @b{(input)}Pointer to the function that is to be invoked upon
*                                   the timer's expiry
* @param    pParam       @b{(input)}A parameter (opaque to the timer lib) that the application
*                                   prefers to be passed along to the expiry function
* @param    timeOut      @b{(input)}Timeout, in Application Timer base ticks.
*
* @returns  tmrHandle     Opaque Application Timer handle, if successful.
*                         This handle, alongwith the Timer Module Control Block,
*                         uniquely identifies the specific timer within a timer
*                         module instantance and must be used to reference this
*                         timer for all other operations (eg.appTmrDelete,
*                         appTmrUpdate, etc).
* @returns   NULLPTR    If operation failed
*
* @notes    The timeOut parameter MUST be in reference to the base application
*           timer instance's ticks. Please refer to the appTimerInit() call for
*           further reference.
*           As an example, if the appTimerInit() was invoked with  APP_TMR_100MSEC
*           for the timerType, then to get a timeout of 1 second, this function
*           must be called with a timeOut value of 10 (1 second = 10 * 10 msec).
*
* @end
*
*********************************************************************/
#define appTimerAdd(timerCtrlBlk,pFunc,pParam,timeOut,timerName)     \
    appTimerAdd_track(timerCtrlBlk,pFunc,pParam,timeOut,timerName,__FILE__,__LINE__)

extern  APP_TMR_HNDL_t appTimerAdd_track( APP_TMR_CTRL_BLK_t timerCtrlBlk,
                                      app_tmr_fn         pFunc,
                                     void                  *pParam,
                                     uint32             timeOut,
                                      char8              *timerName,
                                      char8              *fileName,
                                     uint32             lineNum);

/*********************************************************************
*
* @purpose  Delete an Application Timer
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance from which the timer is being deleted from
* @param    timerHandle  @b{(input)}Timer Handle associated with the specific timer
*                                   being deleted
*
* @returns   SUCCESS   Timer deletion succesful
* @returns   FAILURE   If timer deletion failed; either due to invalid parameters
*                        or that the timer had already popped
*
* @notes    None
*
* @end
*
*********************************************************************/
extern RC_t appTimerDelete( APP_TMR_CTRL_BLK_t timerCtrlBlk,
                               APP_TMR_HNDL_t     timerHandle);

/*********************************************************************
*
* @purpose  Update an Application Timer
*
* @param   timerCtrlBlk  @b{(input)}Application Timer Control Block associated with the
*                                    instance on which the timer is being updated
* @param   timerHandle    @b{(input)}Timer Handle associated with the specific timer
*                                    being updated
* @param   pFunc         @b{(input)}New Timer Expiry function. If  NULLPTR is given,
*                                    then the existing function pointer is left as is
* @param   pParam        @b{(input)}New parameter to be passed to the expiry function.
*                                    If  NULLPTR is given, then the existing parameter
*                                    value is left as is
* @param   timeOut       @b{(input)}New timeout value (in App Timer Ticks). The new timeOut
*                                   value is effective from the time this function is invoked
*                                   and not from the original addition time
*
* @returns   SUCCESS   Timer updation succesful
*            FAILURE   If timer updation failed; either due to invalid parameters
*                        or that the timer had already popped
*
* @notes    Due to the nature of the definition of the pParam above, one
*           cannot update the parameter to a NULL pointer or to a 0 value (if
*           the pParam was actually a uint32 being typecasted). To achieve
*           this the caller is forced to do a appTimerDelete(), followed by a
*           appTimerAdd()
*
* @end
*
*********************************************************************/
#define appTimerUpdate(timerCtrlBlk,timerHandle,pFunc,pParam,timeOut,timerName)     \
    appTimerUpdate_track(timerCtrlBlk,timerHandle,pFunc,pParam,timeOut,timerName,__FILE__,__LINE__)
extern RC_t appTimerUpdate_track( APP_TMR_CTRL_BLK_t timerCtrlBlk,
                               APP_TMR_HNDL_t     *timerHandle,
                              void                  *pFunc,
                              void                  *pParam,
                              uint32             timeOut,
                               uchar8             *timerName,
                               uchar8             *fileName,
                              uint32             lineNum);

/*********************************************************************
*
* @purpose  Retrieve the time left for the given timer to expire
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance on which the timer is active
* @param    timerHandle  @b{(input)}Timer Handle associated with the specific timer
* @param    pTimeLeft    @b{(input)}Pointer to the output parameter that would be filled-in
*                                   with the time remaining (in multiples of the base
*                                   timer instance's granularity) for the timer to expire
*
* @returns   SUCCESS   Operation succesful
* @returns   FAILURE   Operation failed; either due to invalid parameters
*                        or that the timer had already popped
*
* @end
*
*********************************************************************/
extern RC_t appTimerTimeLeftGet( APP_TMR_CTRL_BLK_t timerCtrlBlk,
                                    APP_TMR_HNDL_t     timerHandle,
                                   uint32             *pTimeLeft);

/*********************************************************************
*
* @purpose  Process an Application Timer tick
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance for which the timer tick is to be processed
*
* @returns  None
*
* @notes    This function MUST be invoked by the application (in its own context)
*           in response to a callback from the timer instance using dispatchFn
*           that was earlier registered with the library. The actual timer
*           expiry evaluations and the associated function invokations are
*           carried out in this function's caller's context.
*
* @end
*
*********************************************************************/
extern void appTimerProcess( APP_TMR_CTRL_BLK_t timerCtrlBlk);

/******************************************************************************
* @purpose 
*
* @param   
*
* @returns   SUCCESS
* @returns   FAILURE
*
* @comments     
*     
* @end
******************************************************************************/
extern uint32 appTimerCbMemSizeGet(uint32   maxAppTimers);

/******************************************************************************
* @purpose 
*
* @param   
*
* @returns   SUCCESS
* @returns   FAILURE
*
* @comments     
*     
* @end
******************************************************************************/
extern void appTimerDebugShow( APP_TMR_CTRL_BLK_t timerCtrlBlk);

/*********************************************************************
*
* @purpose  Get pointer to the call back data
*
* @param    timerCtrlBlk @b{(input)}Application Timer Control Block associated with the
*                                   instance from which the timer is being deleted from
*           timerHandle  @b{(input)}Timer Handle associated with the specific timer
*                                   being deleted
*           cbDataPtr    @b{(input)}Pointer to return timer associated data
*
* @returns   SUCCESS    Call back data retrieve succesful
*            FAILURE    Due to invalid parameters
*
* @notes    None
*
* @end
*
*********************************************************************/
RC_t appTimerCbDataGet( APP_TMR_CTRL_BLK_t timerCtrlBlk,
                           APP_TMR_HNDL_t     timerHandle,
                          void                  **cbDataPtr);

/********************* Constant definitions **********************/
#define APPTIMER_DEBUG   

#ifdef APPTIMER_DEBUG
#undef APPTIMER_DEBUG
#endif

#define APPTIMER_STR_LEN 10
typedef struct
{
   sll_member_t *next;      /* Link to next entry */
  uint32       expiryTime; /* Expiry time of this entry */
   app_tmr_fn   expiryFn;
  void            *pParam;
#ifdef APPTIMER_DEBUG  
   uchar8       name[APPTIMER_STR_LEN];
#endif
} timerNode_t;

#define    APP_TMR_NODE_SIZE         sizeof(timerNode_t)  /* size of timer node timerNode_t */


#endif  /*  _APP_TIMER_H  */


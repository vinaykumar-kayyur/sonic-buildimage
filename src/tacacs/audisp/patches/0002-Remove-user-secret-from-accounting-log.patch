From c327217989b77a215d346e07b1e1490a9ab33070 Mon Sep 17 00:00:00 2001
From: liuh-80 <58683130+liuh-80@users.noreply.github.com>
Date: Tue, 9 Nov 2021 16:39:50 +0800
Subject: [PATCH] Remove user secret from accounting log.

---
 Makefile.am                 |   2 +-
 audisp-tacplus.c            |  19 ++-
 regex_helper.c              |  86 ++++++++++++++
 regex_helper.h              |  13 ++
 trace.c                     |  21 ++++
 trace.h                     |  10 ++
 unittest/Makefile           |  20 ++++
 unittest/mock_helper.c      |  55 +++++++++
 unittest/mock_helper.h      |  49 ++++++++
 unittest/sudoers            |   4 +
 unittest/user_secret_test.c | 155 ++++++++++++++++++++++++
 user_secret.c               | 230 ++++++++++++++++++++++++++++++++++++
 user_secret.h               |  35 ++++++
 13 files changed, 696 insertions(+), 3 deletions(-)
 create mode 100644 regex_helper.c
 create mode 100644 regex_helper.h
 create mode 100644 trace.c
 create mode 100644 trace.h
 create mode 100644 unittest/Makefile
 create mode 100644 unittest/mock_helper.c
 create mode 100644 unittest/mock_helper.h
 create mode 100644 unittest/sudoers
 create mode 100644 unittest/user_secret_test.c
 create mode 100644 user_secret.c
 create mode 100644 user_secret.h

diff --git a/Makefile.am b/Makefile.am
index b476e38..6d7a7a0 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -4,7 +4,7 @@
 EXTRA_DIST = ChangeLog README audisp_tacplus.spec \
 	audisp-tac_plus.conf audisp-tacplus.conf
 
-audisp_tacplus_SOURCES = audisp-tacplus.c
+audisp_tacplus_SOURCES = audisp-tacplus.c user_secret.c regex_helper.c trace.c
 audisp_tacplus_CFLAGS = -O
 audisp_tacplus_LDADD = -lauparse -ltacsupport -ltac
 sbin_PROGRAMS = audisp-tacplus
diff --git a/audisp-tacplus.c b/audisp-tacplus.c
index 9884562..134b976 100644
--- a/audisp-tacplus.c
+++ b/audisp-tacplus.c
@@ -65,6 +65,8 @@
 /* Tacacs+ support lib */
 #include <libtac/support.h>
 
+/* Remove user secret */
+#include "user_secret.h"
 
 #define _VMAJ 1
 #define _VMIN 0
@@ -85,6 +87,9 @@ const char *unknown_hostname = "UNK";
 /* Config file path */
 const char *tacacs_config_file = "/etc/tacplus_nss.conf";
 
+/* User secret setting file */
+const char *sudoers_path = "/etc/sudoers";
+
 /* Local declarations */
 static void handle_event(auparse_state_t *au,
 		auparse_cb_event_t cb_event_type, void *user_data);
@@ -171,6 +176,10 @@ main(int argc, char *argv[])
 		syslog(LOG_ERR, "exitting due to auparse init errors");
 		return -1;
 	}
+    
+    /* initialize user secret regex setting */
+    initialize_user_secret_setting(sudoers_path);
+
 	auparse_add_callback(au, handle_event, NULL, NULL);
 	do {
 		/* Load configuration */
@@ -199,6 +208,9 @@ main(int argc, char *argv[])
 	auparse_flush_feed(au);
 	auparse_destroy(au);
 
+    /* Release user secret setting */
+    release_user_secret_setting();
+
 	return 0;
 }
 
@@ -488,11 +500,14 @@ static void get_acct_record(auparse_state_t *au, int type)
     /*
      * loguser is always set, we bail if not.  For ANOM_ABEND, tty may be
      *  unknown, and in some cases, host may be not be set.
-     */
-    send_tacacs_acct(loguser, tty?tty:"UNK", host, logbase, acct_type, taskno);
+     */
+    char* fixed_log_buffer = remove_user_secret(logbase);
+    send_tacacs_acct(loguser, tty?tty:"UNK", host, (fixed_log_buffer != NULL)?fixed_log_buffer:logbase, acct_type, taskno);
 
     if(freeloguser)
         free(loguser);
+
+    free(fixed_log_buffer);
 }
 
 /*
diff --git a/regex_helper.c b/regex_helper.c
new file mode 100644
index 0000000..bddbb18
--- /dev/null
+++ b/regex_helper.c
@@ -0,0 +1,86 @@
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <stdlib.h>
+
+#include "user_secret.h"
+#include "trace.h"
+
+#define min(a,b)            (((a) < (b)) ? (a) : (b))
+
+/* 
+ * Macros for user secret regex
+ * These are BRE regex, please refer to: https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions
+ */
+#define USER_SECRET_REGEX_WHITE_SPACE              "[[:space:]]*"
+#define USER_SECRET_REGEX_SECRET                   "\\([^[:space:]]*\\)"
+
+/* Regex match group count, 2 because only have 1 subexpression for user secret */
+#define REGEX_MATCH_GROUP_COUNT      2
+
+/* The user secret mask */
+#define USER_SECRET_MASK                   '*'
+
+/* Replace user secret with regex */
+char * remove_user_secret_by_regex(const char* command, regex_t regex)
+{
+    regmatch_t pmatch[REGEX_MATCH_GROUP_COUNT];
+    if (regexec(&regex, command, REGEX_MATCH_GROUP_COUNT, pmatch, 0) == REG_NOMATCH) {
+        trace("User command not match.\n");
+        return NULL;
+    }
+
+    if (pmatch[1].rm_so < 0) {
+        trace("User secret not found.\n");
+        return NULL;
+    }
+
+    /* Found user secret between pmatch[1].rm_so to pmatch[1].rm_eo, replace it. */
+    trace("Found user secret between: %d -- %d\n", pmatch[1].rm_so, pmatch[1].rm_eo);
+    int result_buffer_size = strlen(command) + 1;
+    char * result_buffer = malloc(result_buffer_size);
+    snprintf(result_buffer, result_buffer_size, "%s", command);
+
+    /* Replace user secret with mask. */
+    int secret_start_pos = min(pmatch[1].rm_so, result_buffer_size - 1);
+    int secret_count = min(pmatch[1].rm_eo, result_buffer_size - 1) - secret_start_pos;
+    memset(result_buffer + secret_start_pos, USER_SECRET_MASK, secret_count);
+
+    return result_buffer;
+}
+
+/* Convert user secret setting to regex. */
+void convert_secret_setting_to_regex(char *buf, size_t buf_size, const char* secret_setting)
+{
+    int src_idx = 0;
+    int last_char_is_whitespace = 0;
+
+    memset(buf, 0, buf_size);
+    while (secret_setting[src_idx]) {
+        int buffer_used_space= strlen(buf);
+        if (secret_setting[src_idx] == USER_SECRET_MASK) {
+            /* Replace * to USER_SECRET_REGEX_SECRET */
+            snprintf(buf + buffer_used_space, buf_size - buffer_used_space,USER_SECRET_REGEX_SECRET);
+        }
+        else if (isspace(secret_setting[src_idx])) {
+            /* Ignore mutiple whitespace */
+            if (!last_char_is_whitespace) {
+                /* Replace whitespace to regex USER_SECRET_REGEX_WHITE_SPACE which match multiple whitespace */
+                snprintf(buf + buffer_used_space, buf_size - buffer_used_space,USER_SECRET_REGEX_WHITE_SPACE);
+            }
+        }
+        else if (buffer_used_space < buf_size - 1){
+            /* Copy none user secret characters */
+            buf[buffer_used_space] = secret_setting[src_idx];
+        }
+        else {
+            /* Buffer full, return here. */
+            return;
+        }
+
+        last_char_is_whitespace = isspace(secret_setting[src_idx]);
+        src_idx++;
+    }
+}
\ No newline at end of file
diff --git a/regex_helper.h b/regex_helper.h
new file mode 100644
index 0000000..e2478eb
--- /dev/null
+++ b/regex_helper.h
@@ -0,0 +1,13 @@
+#ifndef REGEX_HELPER_H
+#define REGEX_HELPER_H
+
+#include <regex.h>
+#include <string.h>
+
+/* Replace user secret with regex */
+extern char * remove_user_secret_by_regex(const char* command, regex_t regex);
+
+/* Convert user secret setting to regex. */
+extern void convert_secret_setting_to_regex(char *buf, size_t buf_size, const char* secret_setting);
+
+#endif /* REGEX_HELPER_H */
\ No newline at end of file
diff --git a/trace.c b/trace.c
new file mode 100644
index 0000000..44bbbc7
--- /dev/null
+++ b/trace.c
@@ -0,0 +1,21 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <stdlib.h>
+
+#include "trace.h"
+
+/* Output trace log. */
+void trace(const char *format, ...)
+{
+    // convert log to a string because va args resoursive issue:
+    // http://www.c-faq.com/varargs/handoff.html
+    char logBuffer[MAX_LINE_SIZE];
+    va_list args;
+    va_start (args, format);
+    vsnprintf(logBuffer, sizeof(logBuffer), format, args);
+    va_end (args);
+
+    syslog(LOG_INFO, "Audisp-tacplus: %s", logBuffer);
+}
\ No newline at end of file
diff --git a/trace.h b/trace.h
new file mode 100644
index 0000000..6ea929d
--- /dev/null
+++ b/trace.h
@@ -0,0 +1,10 @@
+#ifndef TRACE_H
+#define TRACE_H
+
+/* Max setting line buffer size */
+#define MAX_LINE_SIZE                              512
+
+/* Output trace log. */
+extern void trace(const char *format, ...);
+
+#endif /* USER_SECRED_H */
\ No newline at end of file
diff --git a/unittest/Makefile b/unittest/Makefile
new file mode 100644
index 0000000..d2e05ed
--- /dev/null
+++ b/unittest/Makefile
@@ -0,0 +1,20 @@
+#disable some warning because UT need test functions not in header file.
+CFLAGS = -Wno-parentheses -Wno-format-security -Wno-implicit-function-declaration -c
+IFLAGS = -I.. -I../include -I../lib
+MFLAG = -DDEBUG -DUNIT_TEST
+
+all:
+	gcc user_secret_test.c $(IFLAGS) $(CFLAGS) -o user_secret_test.o
+	gcc mock_helper.c $(IFLAGS) $(CFLAGS) -o mock_helper.o
+	gcc ../user_secret.c   $(IFLAGS) $(CFLAGS) $(MFLAG) -o user_secret.o
+	gcc ../regex_helper.c   $(IFLAGS) $(CFLAGS) $(MFLAG) -o regex_helper.o
+	gcc ../trace.c   $(IFLAGS) $(CFLAGS) $(MFLAG) -o trace.o
+	gcc  user_secret_test.o  mock_helper.o user_secret.o regex_helper.o trace.o -o user_secret_test  -lc -lcunit 
+
+test:
+	# run unit test, if UT failed, build will break
+	./user_secret_test
+
+clean:
+	rm *.o
+	rm user_secret_test
diff --git a/unittest/mock_helper.c b/unittest/mock_helper.c
new file mode 100644
index 0000000..0a7a5a7
--- /dev/null
+++ b/unittest/mock_helper.c
@@ -0,0 +1,55 @@
+/* mock_helper.c -- mock helper for bash plugin UT. */
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <CUnit/CUnit.h>
+#include <CUnit/Basic.h>
+#include "mock_helper.h"
+
+/* define test scenarios for mock functions return different value by scenario. */
+int test_scenario;
+
+/* define memory allocate counter. */
+int memory_allocate_count;
+
+/* Set test scenario for test*/
+void set_test_scenario(int scenario)
+{
+    test_scenario = scenario;
+}
+
+/* Get test scenario for test*/
+int get_test_scenario()
+{
+    return test_scenario;
+}
+
+/* Set memory allocate count for test*/
+void set_memory_allocate_count(int count)
+{
+    memory_allocate_count = count;
+}
+
+/* Get memory allocate count for test*/
+int get_memory_allocate_count()
+{
+    return memory_allocate_count;
+}
+
+
+/* MOCK malloc method*/
+void *mock_malloc(size_t size)
+{
+    memory_allocate_count++;
+    debug_printf("MOCK: malloc %ld bytes memory count: %d\n", size, memory_allocate_count);
+    return malloc(size);
+}
+
+/* MOCK free method*/
+void mock_free(void* ptr)
+{
+    memory_allocate_count--;
+    debug_printf("MOCK: free memory count: %d\n", memory_allocate_count);
+    free(ptr);
+}
\ No newline at end of file
diff --git a/unittest/mock_helper.h b/unittest/mock_helper.h
new file mode 100644
index 0000000..b2cf33f
--- /dev/null
+++ b/unittest/mock_helper.h
@@ -0,0 +1,49 @@
+/* plugin.h - functions from plugin.c. */
+
+/* Copyright (C) 1993-2015 Free Software Foundation, Inc.
+
+   This file is part of GNU Bash, the Bourne Again SHell.
+
+   Bash is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   Bash is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with Bash.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#if !defined (_MOCK_HELPER_H_)
+#define _MOCK_HELPER_H_
+
+#include "user_secret.h"
+
+// define USER_SECRET_UT_DEBUG to output UT debug message.
+#define USER_SECRET_UT_DEBUG
+#if defined (USER_SECRET_UT_DEBUG)
+#define debug_printf printf
+#else
+#define debug_printf
+#endif
+
+#define TEST_SCEANRIO_LOAD_USER_SECRET_SETTING  	1
+
+/* Set test scenario for test*/
+void set_test_scenario(int scenario);
+
+/* Get test scenario for test*/
+int get_test_scenario();
+
+/* Set memory allocate count for test*/
+void set_memory_allocate_count(int count);
+
+/* Get memory allocate count for test*/
+int get_memory_allocate_count();
+
+
+#endif /* _MOCK_HELPER_H_ */
\ No newline at end of file
diff --git a/unittest/sudoers b/unittest/sudoers
new file mode 100644
index 0000000..25829f3
--- /dev/null
+++ b/unittest/sudoers
@@ -0,0 +1,4 @@
+# test file for read user secret setting
+
+Cmnd_Alias      PASSWD_CMDS = /usr/local/bin/config tacacs passkey *, \ 
+                              /usr/sbin/chpasswd *   
\ No newline at end of file
diff --git a/unittest/user_secret_test.c b/unittest/user_secret_test.c
new file mode 100644
index 0000000..c6a4bca
--- /dev/null
+++ b/unittest/user_secret_test.c
@@ -0,0 +1,155 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <CUnit/CUnit.h>
+#include <CUnit/Basic.h>
+
+#include "mock_helper.h"
+#include "regex_helper.h"
+#include "trace.h"
+#include "user_secret.h"
+
+/* Regex list */
+extern REGEX_NODE *global_regex_list;
+
+int clean_up() {
+  return 0;
+}
+
+int start_up() {
+  return 0;
+}
+
+/* Test load user secret setting*/
+void testcase_load_user_secret_setting() {
+    set_test_scenario(TEST_SCEANRIO_LOAD_USER_SECRET_SETTING);
+    initialize_user_secret_setting("./sudoers");
+
+    int loaded_regex_count = 0;
+    REGEX_NODE *next_node = global_regex_list;
+    while (next_node != NULL) {
+        /* Continue with next pligin */
+        REGEX_NODE* current_node_memory = next_node;
+        next_node = next_node->next;
+        
+        loaded_regex_count++;
+    }
+
+    release_user_secret_setting();
+
+    CU_ASSERT_EQUAL(loaded_regex_count, 2);
+}
+
+/* Test convert setting string to regex string*/
+void testcase_convert_secret_setting_to_regex() {
+    char regex_buffer[MAX_LINE_SIZE];
+    
+    /* '*' in input setting should replace to (\S*) */
+    convert_secret_setting_to_regex(regex_buffer, sizeof(regex_buffer), "testcommand    *");
+    debug_printf("regex_buffer: %s\n", regex_buffer);
+    CU_ASSERT_STRING_EQUAL(regex_buffer, "testcommand[[:space:]]*\\([^[:space:]]*\\)");
+
+    convert_secret_setting_to_regex(regex_buffer, sizeof(regex_buffer), "/usr/sbin/chpasswd *");
+    debug_printf("regex_buffer: %s\n", regex_buffer);
+    CU_ASSERT_STRING_EQUAL(regex_buffer, "/usr/sbin/chpasswd[[:space:]]*\\([^[:space:]]*\\)");
+}
+
+/* Test fix user secret by regex*/
+void testcase_fix_user_secret_by_regex() {
+    char regex_buffer[MAX_LINE_SIZE];
+
+    /* '*' in input setting should replace to (\S*) */
+    convert_secret_setting_to_regex(regex_buffer, sizeof(regex_buffer), "testcommand    *");
+    debug_printf("regex_buffer: %s\n", regex_buffer);
+    
+    /* Fixed regex should be a correct regex */
+    regex_t regex;
+    CU_ASSERT_FALSE(regcomp(&regex, regex_buffer, REG_NEWLINE));
+    
+    /* User secret should be removed by regex */
+    char* result_buffer = remove_user_secret_by_regex("testcommand  testsecret", regex);
+    CU_ASSERT_TRUE(result_buffer != NULL);
+    
+    debug_printf("Fixed command: %s\n", result_buffer);
+    CU_ASSERT_STRING_EQUAL(result_buffer, "testcommand  **********");
+    free(result_buffer);
+}
+
+/* Test fix user secret*/
+void testcase_fix_user_secret() {
+    initialize_user_secret_setting("./sudoers");
+
+    /* User secret should be removed by regex */
+    char* result_buffer = remove_user_secret("/usr/local/bin/config tacacs passkey  testsecret");
+    CU_ASSERT_TRUE(result_buffer != NULL);
+
+    debug_printf("Fixed command: %s\n", result_buffer);
+    CU_ASSERT_STRING_EQUAL(result_buffer, "/usr/local/bin/config tacacs passkey  **********");
+    free(result_buffer);
+
+    result_buffer = remove_user_secret("/usr/sbin/chpasswd   testsecret");
+    CU_ASSERT_TRUE(result_buffer != NULL);
+
+    debug_printf("Fixed command: %s\n", result_buffer);
+    CU_ASSERT_STRING_EQUAL(result_buffer, "/usr/sbin/chpasswd   **********");
+    free(result_buffer);
+
+    /* Regular command not change */
+    result_buffer = remove_user_secret("command no user secret");
+    CU_ASSERT_TRUE(result_buffer == NULL);
+
+    release_user_secret_setting();
+}
+
+/* Test release all regex */
+void testcase_release_all_regex() {
+    set_memory_allocate_count(0);
+    
+    initialize_user_secret_setting("./sudoers");
+    release_user_secret_setting();
+
+    /* All memory should free */
+    CU_ASSERT_EQUAL(get_memory_allocate_count(), 0);
+}
+
+int main(void) {
+    if (CUE_SUCCESS != CU_initialize_registry()) {
+        return CU_get_error();
+    }
+
+    CU_pSuite ste = CU_add_suite("plugin_test", start_up, clean_up);
+    if (NULL == ste) {
+    CU_cleanup_registry();
+        return CU_get_error();
+    }
+
+    if (CU_get_error() != CUE_SUCCESS) {
+    fprintf(stderr, "Error creating suite: (%d)%s\n", CU_get_error(), CU_get_error_msg());
+        return CU_get_error();
+    }
+
+    if (!CU_add_test(ste, "Test testcase_load_user_secret_setting()...\n", testcase_load_user_secret_setting)
+      || !CU_add_test(ste, "Test testcase_convert_secret_setting_to_regex()...\n", testcase_convert_secret_setting_to_regex)
+      || !CU_add_test(ste, "Test testcase_fix_user_secret_by_regex()...\n", testcase_fix_user_secret_by_regex)
+      || !CU_add_test(ste, "Test testcase_fix_user_secret()...\n", testcase_fix_user_secret)
+      || !CU_add_test(ste, "Test testcase_release_all_regex()...\n", testcase_release_all_regex)) {
+    CU_cleanup_registry();
+        return CU_get_error();
+    }
+
+    if (CU_get_error() != CUE_SUCCESS) {
+        fprintf(stderr, "Error adding test: (%d)%s\n", CU_get_error(), CU_get_error_msg());
+    }
+
+    // run all test
+    CU_basic_set_mode(CU_BRM_VERBOSE);
+    CU_ErrorCode run_errors = CU_basic_run_suite(ste);
+    if (run_errors != CUE_SUCCESS) {
+        fprintf(stderr, "Error running tests: (%d)%s\n", run_errors, CU_get_error_msg());
+    }
+
+    CU_basic_show_failures(CU_get_failure_list());
+
+    // use failed UT count as return value
+    return CU_get_number_of_failure_records();
+}
diff --git a/user_secret.c b/user_secret.c
new file mode 100644
index 0000000..94baf81
--- /dev/null
+++ b/user_secret.c
@@ -0,0 +1,230 @@
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <syslog.h>
+#include <stdlib.h>
+
+#include "regex_helper.h"
+#include "trace.h"
+#include "user_secret.h"
+
+// use mock functions when build for UT
+#if defined (UNIT_TEST)
+void *mock_malloc(size_t size);
+void mock_free(void* ptr);
+#define malloc  mock_malloc
+#define free    mock_free
+#else
+#endif
+
+/* Macros for have_next_line result */
+#define HAVE_NEXT_SETTING_LINE 1
+#define NO_NEXT_SETTING_LINE   0
+
+/* Macros for parse user input */
+#define USER_COMMAND_TOKEN_WHITESPACE              " \t\n\r\f"
+#define USER_COMMAND_TOKEN_SETTING_SPLITTER        " =\t"
+#define USER_COMMAND_TOKEN_EQUAL                   "="
+#define USER_COMMAND_TOKEN_COMMA                   ","
+
+/* The command alias prefix */
+const char* COMMAND_ALIAS = "Cmnd_Alias";
+
+/* The user secret setting */
+const char* USER_SECRET_SETTING = "PASSWD_CMDS";
+
+/* Regex list */
+REGEX_NODE *global_regex_list = NULL;
+
+/* Append regex to list */
+int append_regex_to_list(regex_t regex)
+{
+    /* Create and initialize regex node */
+    REGEX_NODE *new_regex_node = (REGEX_NODE *)malloc(sizeof(REGEX_NODE));
+    if (new_regex_node == NULL)
+    {
+        /* When allocate memory failed, stop and return. also output log to both syslog and stderr with LOG_PERROR*/
+        trace("Failed to allocate memory for regex node.\n");
+        return REGEX_APPEND_FAILED;
+    }
+
+    new_regex_node->next = NULL;
+    new_regex_node->regex = regex;
+
+    /* Find the pointer to the latest regex node's 'next' field */
+    REGEX_NODE **current_node = &global_regex_list;
+    while (*current_node != NULL) {
+        current_node = &((*current_node)->next);
+    }
+    
+    /* append new regex to tail node */
+    *current_node = new_regex_node;
+    return REGEX_APPEND_SUCCESS;
+}
+
+/* Release user secret setting */
+void release_user_secret_setting()
+{
+    if (global_regex_list == NULL) {
+        return;
+    }
+
+    /* Walk to last regex */
+    REGEX_NODE *next_node = global_regex_list;
+    while (next_node != NULL) {
+        /* Continue with next regex */
+        REGEX_NODE* current_node_memory = next_node;
+        next_node = next_node->next;
+        
+        /* Free node memory, this may also reset all allocated memory depends on c lib implementation */
+        free(current_node_memory);
+    }
+
+    /* Reset list */
+    global_regex_list = NULL;
+}
+
+/* Replace user secret with regex */
+char * remove_user_secret(const char* command)
+{
+    if (global_regex_list == NULL) {
+        return NULL;
+    }
+
+    /* Check every regex */
+    REGEX_NODE *next_node = global_regex_list;
+    while (next_node != NULL) {
+        /* Try fix user secret with current regex */
+        char* fixed_command = remove_user_secret_by_regex(command, next_node->regex);
+        if (fixed_command != NULL) {
+            return fixed_command;
+        }
+        
+        /* If user secret not fix, continue try next regex */
+        next_node = next_node->next;
+    }
+
+    return NULL;
+}
+
+/* Trim start */
+char* trim_start(char *str)
+{
+    if (str == NULL) {
+        return str;
+    }
+
+    while (isspace(*str)) {
+        str++;
+    }
+
+    return str;
+}
+
+/* Check setting if have next line */
+int check_have_next_line(const char *str)
+{
+    if (str == NULL) {
+        return NO_NEXT_SETTING_LINE;
+    }
+
+    /* Find end of string */
+    const char* endpos = str;
+    while (*endpos) {
+        endpos++;
+    }
+
+    /* Find last none whitespace character */
+    char last_none_whitespace_char = 0;
+    while (endpos-- > str) {
+        if (!isspace(*endpos)) {
+            last_none_whitespace_char = *endpos;
+            break;
+        }
+    }
+
+    /* If the string end with \, then have next setting line */
+    if (last_none_whitespace_char == '\\') {
+        return HAVE_NEXT_SETTING_LINE;
+    }
+
+    return NO_NEXT_SETTING_LINE;
+}
+
+/* Append user secret setting to global list */
+int append_user_secret_setting(const char *setting_str)
+{
+    trace("Append user secret regex: %s\n", setting_str);
+
+    /* convert the setting string to regex */
+    char regex_buffer[MAX_LINE_SIZE];
+    convert_secret_setting_to_regex(regex_buffer, sizeof(regex_buffer), setting_str);
+
+    regex_t regex;
+    if (regcomp(&regex, regex_buffer, REG_NEWLINE)) {
+        trace("Complie regex failed: %s\n", regex_buffer);
+        return INITIALIZE_INCORRECT_REGEX;
+    }
+
+    /* Append regex to global list */
+    append_regex_to_list(regex);
+
+    return INITIALIZE_SUCCESS;
+}
+
+/* Initialize user secret setting */
+int initialize_user_secret_setting(const char *setting_path)
+{
+    int result = INITIALIZE_SUCCESS;
+    char line_buffer[MAX_LINE_SIZE];
+    FILE *setting_file= fopen(setting_path, "r");
+    if(setting_file == NULL) {
+        return INITIALIZE_OPEN_SETTING_FILE_FAILED;
+    }
+
+    int continue_parse_user_secret = 0;
+    while (fgets(line_buffer, sizeof line_buffer, setting_file)) {
+        char* token;
+        if (!continue_parse_user_secret) {
+            token = strtok(line_buffer, USER_COMMAND_TOKEN_WHITESPACE);
+            if (!token) {
+                /* Empty line will not get any token */
+                continue;
+            }
+
+            /* Not continue check unfinished multiple line settings */
+            if (strncmp(token, COMMAND_ALIAS, strlen(COMMAND_ALIAS))) {
+                /* Ignore current line when current line is not a command alias */
+                continue;
+            }
+
+            token = strtok(NULL, USER_COMMAND_TOKEN_SETTING_SPLITTER);
+            if (strncmp(token, USER_SECRET_SETTING, strlen(USER_SECRET_SETTING))) {
+                /* Ignore current line when current line is not a user secret setting */
+                continue;
+            }
+
+            /* Get user secret setting content */
+            token = strtok(NULL, USER_COMMAND_TOKEN_EQUAL);
+        }
+        else {
+            /* The strok will return setting before first whitespace, so need use origional buffer */
+            token = line_buffer;
+        }
+
+        /* Check if have next setting line */
+        continue_parse_user_secret = check_have_next_line(token);
+
+        /* Get settings before comma */
+        token = strtok(token, USER_COMMAND_TOKEN_COMMA);
+        token = trim_start(token);
+
+        /* Append setting regex */
+        append_user_secret_setting(token);
+    }
+
+    fclose(setting_file);
+
+    return result;
+}
\ No newline at end of file
diff --git a/user_secret.h b/user_secret.h
new file mode 100644
index 0000000..dd15d99
--- /dev/null
+++ b/user_secret.h
@@ -0,0 +1,35 @@
+#ifndef USER_SECRED_H
+#define USER_SECRED_H
+
+#include <string.h>
+#include <regex.h>
+
+/* Macros for initialize result */
+#define INITIALIZE_SUCCESS                         0
+#define INITIALIZE_OPEN_SETTING_FILE_FAILED        1
+#define INITIALIZE_INCORRECT_REGEX                 2
+
+/* Regex append result. */
+#define REGEX_APPEND_SUCCESS              0
+#define REGEX_APPEND_FAILED               1
+
+/* Regex fix result. */
+#define USER_SECRET_FIXED                 0
+#define USER_SECRET_NOT_FOUND             1
+
+/* Regex list node. */
+typedef struct regex_node {
+    struct regex_node *next;
+    regex_t regex;
+} REGEX_NODE;
+
+/* Initialize user secret setting */
+extern int initialize_user_secret_setting(const char *setting_path);
+
+/* Release user secret setting */
+extern void release_user_secret_setting();
+
+/* Replace user secret with regex */
+extern char * remove_user_secret(const char* command);
+
+#endif /* USER_SECRED_H */
\ No newline at end of file
-- 
2.17.1.windows.2


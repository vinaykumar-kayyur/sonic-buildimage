# {C} Copyright 2023 AMD Systems Inc. All rights reserved
#############################################################################
# Pensando
#
# Module contains an implementation of APIs for fetch interrutps from docker-dpu
# and listens to event generated by dpu. This get used by sonic-interruptd
#
#############################################################################

import sys
import threading
import time
from datetime import datetime
from pathlib import Path
sys.path.append(str(Path(__file__).parent.absolute()))

from sonic_platform import interrupt_pb2, interrupt_pb2_grpc, oper_pb2, oper_pb2_grpc
from sonic_py_common import logger
import grpc
import syslog

LOCALHOST = "127.0.0.1"
PDS_PORT = 11357
EVENT_PORT = 11360
ERR_UNKNOWN = 1
GRPC_CHANNEL_TIMEOUT = 10
SEVERITY_TABLE = {
    0 : "LEVEL_NONE"  ,
    1 : "LEVEL_FATAL" ,
    2 : "LEVEL_HW_RMA",
    3 : "LEVEL_ERROR" ,
    4 : "LEVEL_INFO"  ,
}

NOT_AVAILABLE = 'N/A'
SYSLOG_IDENTIFIER = 'interruptd'

INTERRUPT_EVENT = [4001, 4002, 4003]
EMMC_HEALTH_EVENT = [16]

def log_emerg(msg):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_EMERG,msg)
    syslog.closelog()

# operd event functions
g_count = 0

class EventHandler(logger.Logger):

    def __init__(self):
        super(EventHandler, self).__init__(SYSLOG_IDENTIFIER)
        self.events = []
        self.events.extend(EMMC_HEALTH_EVENT)
        self.events.extend(INTERRUPT_EVENT)
        self.event_thread = None
        self.event_stop = False

    def _getGrpcEventMessage(self):
        while True:
            if self.event_stop:
                return
            grpcmsg = oper_pb2.OperInfoRequest()
            spec = grpcmsg.Request.add()
            spec.InfoType = oper_pb2.OPER_INFO_TYPE_EVENT
            spec.Action = oper_pb2.OPER_INFO_OP_SUBSCRIBE
            for event in self.events:
                spec.EventFilter.Types.append(event)
            yield grpcmsg

    def _process_event(self, event):
        global g_count
        g_count += 1
        log_emerg(f"Event # {g_count} Time -> {time.asctime()}")
        log_emerg(f"Received event {event}")

    def _event_listener(self):
        channel_addr = "{}:{}".format(LOCALHOST,str(EVENT_PORT))
        channel = grpc.insecure_channel(channel_addr)
        stub = oper_pb2_grpc.OperSvcStub(channel)
        resp = stub.OperInfoSubscribe(self._getGrpcEventMessage())
        time.sleep(1)
        for event in resp:
            self._process_event(event)

    def start(self):
        # spawn operd listener thread
        self.event_stop = False
        if (self.event_thread == None) or (not self.event_thread.is_alive()):
            self.event_thread = threading.Thread(target=self._event_listener)
            self.event_thread.daemon = True
            self.event_thread.start()
        self.event_thread.join()

    def stop(self):
        self.log_warning("Stopping event listener thread")
        self.event_stop = True

class InterruptHandler(logger.Logger):

    def __init__(self):
        super(InterruptHandler, self).__init__(SYSLOG_IDENTIFIER)

    def _get_severity_int_to_str(self, severity):
        if isinstance(severity, int):
            return SEVERITY_TABLE.get(severity, NOT_AVAILABLE)
        else:
            return NOT_AVAILABLE

    def _get_datetime_from_proto_timestamp(self, interrupt_time):
        seconds = interrupt_time.seconds
        try:
            timestamp = datetime.fromtimestamp(seconds).strftime('%Y%m%d %H:%M:%S')
            return timestamp
        except:
            return NOT_AVAILABLE

    def _grpc_interrupt_get(self):
        channel_addr = "{}:{}".format(LOCALHOST,str(PDS_PORT))
        response_list = []
        try:
            with grpc.insecure_channel(channel_addr) as channel:
                ch = grpc.intercept_channel(channel)
                grpc.channel_ready_future(ch).result(GRPC_CHANNEL_TIMEOUT)
                stub = interrupt_pb2_grpc.SystemSvcStub(ch)
                response = stub.InterruptGet(interrupt_pb2.InterruptGetRequest(All=True))
                self.log_debug("Interrupt client received: ", response)
                if response.cancelled():
                    return False, None, "grpc channel cancelled"
                if not response.is_active():
                    return True, [], "No interrupts received on grpc channel"
                for r in response:
                    response_list.append(r)
            return True, response_list, "Success"
        except Exception as e:
            return False, None, "grpc request failed with exception {}".format(e)

    def _parse_interrupt(self, interrupt_list):
        info_list = []
        try:
            for interrupt in interrupt_list:
                info = {}
                try:
                    info["Name"] = interrupt.Name
                    info["Description"] = interrupt.Description
                    info["Count"] = interrupt.Count
                    info["Severity"] = self._get_severity_int_to_str(interrupt.Severity)
                    info["Time"] = self._get_datetime_from_proto_timestamp(interrupt.Time)
                    ignore_flag = False
                    if (interrupt.IgnoreOnce and (interrupt.Count <= 1)) or interrupt.IgnoreAll:
                        ignore_flag = True
                    info["Ignore"] = ignore_flag
                    info_list.append(info)
                except:
                    continue
        except:
            return []

        return info_list

    def _parse_interrupt_response(self, response_list):
        interrupt_info = []
        for response in response_list:
            if response.ApiStatus == 0:
                interrupts = response.Interrupt
                info_list = self._parse_interrupt(interrupts)
                interrupt_info.extend(info_list)
        return interrupt_info

    def interrupt_get(self):
        status, response_list, msg = self._grpc_interrupt_get()
        if status:
            interrupt_info_list = self._parse_interrupt_response(response_list)
            return status, interrupt_info_list, msg
        else:
            return status, None, msg

    def get_cleanup_flag(self):
        """
        flag to delete pre existing interrupt entries
        Returns:
            bool
        """
        return True
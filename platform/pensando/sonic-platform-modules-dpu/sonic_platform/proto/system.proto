//
// Copyright(C) Advanced Micro Devices, Inc. All rights reserved.
//
// You may not use this software and documentation (if any) (collectively,
// the "Materials") except in compliance with the terms and conditions of
// the Software License Agreement included with the Materials or otherwise as
// set forth in writing and signed by you and an authorized signatory of AMD.
// If you do not have a copy of the Software License Agreement, contact your
// AMD representative for a copy.
//
// You agree that you will not reverse engineer or decompile the Materials,
// in whole or in part, except as allowed by applicable law.
//
// THE MATERIALS ARE DISTRIBUTED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR
// REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
//


//------------------------------------------------------------------------------

//
// protobuf specification for the top level system object
//------------------------------------------------------------------------------

syntax = "proto3";
package pds;

import "gogo.proto";
import "google/protobuf/timestamp.proto";
import "meta/meta.proto";
import "types.proto";

service SystemSvc {
  rpc SystemGet (types.Empty) returns (SystemGetResponse) {}
  rpc InventoryGet (types.Empty) returns (InventoryGetResponse) {}
  rpc QueueCreditsGet (types.Empty) returns (QueueCreditsGetResponse) {}
  rpc InterruptGet(InterruptGetRequest) returns (stream InterruptGetResponse) {}
}

message TemperatureStats {
  uint32 Temperature       = 1; // current temperature
  uint32 MaxTemperature    = 2; // max temperature recorded
  uint32 MinTemperature    = 3; // min temperature recorded
  double AvgTemperature    = 4; // avg temperature
  double StandardDeviation = 5; // standard deviation
}

message SystemTemperature {
  TemperatureStats DieTemperature   = 1;
  TemperatureStats LocalTemperature = 2;
  TemperatureStats HbmTemperature   = 3;
}

message SystemVoltage {
  uint32 CoreVoltage = 1;
  uint32 ArmVoltage  = 2;
}

// type of the system led values
enum LedStatus {
  LED_STATUS_NONE  = 0;
  LED_STATUS_GREEN = 1;
  LED_STATUS_AMBER = 2;
  LED_STATUS_OFF   = 3;
}

// type of the system reset reason values
enum ResetReason {
  RESET_REASON_UNKNOWN          = 0;
  RESET_REASON_SW_POWER_CYCLE   = 1;
  RESET_REASON_VRD_FAULT        = 2;
  RESET_REASON_THERM_TRIP       = 3;
  RESET_REASON_HOST_POWER_CYCLE = 4;
  RESET_REASON_AC_POWER_CYCLE   = 5;
  RESET_REASON_REBOOT           = 6;
  RESET_REASON_PANIC            = 7;
  RESET_REASON_PCIE_RESET       = 8;
  RESET_REASON_ESECURE_ENABLED  = 9;
  RESET_REASON_ASIC_WARM_RESET  = 10;
}

message PowerStats {
  uint32 Power             = 1; // current power
  uint32 MaxPower          = 2; // max power recorded
  uint32 MinPower          = 3; // min power recorded
  double AvgPower          = 4; // avg power
  double StandardDeviation = 5; // standard deviation
}

message SystemPower {
  PowerStats Pin   = 1;
  PowerStats Pout1 = 2;
  PowerStats Pout2 = 3;
}

message SystemFrequency {
  uint32 ClockFrequency    = 1;
  uint32 ArmClockFrequency = 2;
  uint32 P4StageFrequency  = 3;
}

message SystemCurrent {
  repeated uint32 Current = 1; // list of current sensor values in milliampere
}

// pmbus sensor status for current, voltage and temperature
message PMBusSensorStatus {
  // current value of pmbus sensor in milliampere
  uint32 Current        = 1;
  // max current recorded in milliampere
  uint32 MaxCurrent     = 2;
  // min current recorded in milliampere
  uint32 MinCurrent     = 3;
  // current value of pmbus sensor in millivolts
  uint32 Voltage        = 4;
  // max voltage recorded in millivolts
  uint32 MaxVoltage     = 5;
  // min voltage recorded in millivolts
  uint32 MinVoltage     = 6;
  // temperature value of pmbus sensor in degrees celcius
  uint32 Temperature    = 7;
  // max temperature recorded in degrees celcius
  uint32 MaxTemperature = 8;
  // min temperature recorded in degrees celcius
  uint32 MinTemperature = 9;
}

message SystemGetResponse {
  types.ApiStatus            ApiStatus         = 1;
  ResetReason                ResetReason       = 2;
  string                     DieId             = 3;
  LedStatus                  SystemLed         = 4;
  SystemTemperature          Temperature       = 5;
  SystemVoltage              Voltage           = 6;
  SystemPower                Power             = 7;
  SystemFrequency            Frequency         = 8;
  // emmc lifetimeused in percentage.
  // example: 10 is 0-10 percentage lifetime used
  uint32                     EmmcLifetimeUsed  = 9;
  SystemCurrent              Current           = 10;
  repeated PMBusSensorStatus PMBusSensorStatus = 11;
}

message InventoryDevice {
  string Name         = 1; // name of the device
  string Description  = 2; // device description
  string ProductId    = 3; // product id from the device
  string SerialNumber = 4; // serial number of the device
  string FwVersion    = 5; // firmware version
}

message InventoryGetResponse {
  types.ApiStatus ApiStatus  = 1;
  InventoryDevice DeviceInfo = 2; // device details
}

message ClockFrequencyRequest {
  meta.TypeMeta TypeMeta          = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ",inline"];
  meta.ObjMeta  ObjMeta           = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = "meta,omitempty"];
  uint32        ArmClockFrequency = 3;
  uint32        P4StageFrequency  = 4;
}

message ClockFrequencyResponse {
  types.ApiStatus ApiStatus = 1;
}

message QueueCredit {
  uint32 Queue  = 1;
  uint32 Credit = 2;
}

message PortQueueCredit {
  uint32               Port        = 1;
  repeated QueueCredit QueueCredit = 2;
}

message QueueCreditsGetResponse {
  types.ApiStatus          ApiStatus       = 1;
  repeated PortQueueCredit PortQueueCredit = 2;
}

// interrupt record
message Interrupt {
  // interrupt levels
  enum Level {
    LEVEL_NONE   = 0;
    LEVEL_FATAL  = 1;
    LEVEL_HW_RMA = 2;
    LEVEL_ERROR  = 3;
    LEVEL_INFO   = 4;
  }
  // timestamp when the interrupt was last seen
  google.protobuf.Timestamp Time        = 1 [(gogoproto.stdtime) = true];
  // name of the interrupt
  string                    Name        = 2;
  // severity of the interrupt
  Level                     Severity    = 3;
  // no. of times interrupts was seen so far
  uint64                    Count       = 4;
  // description of the interrupt
  string                    Description = 5;
  // 1st occurance of this interrupt is ignored and if this interrupt happens
  // multiple times, it needs to be looked into
  bool                      IgnoreOnce  = 6;
  // ignore all occurances of this interrupt
  bool                      IgnoreAll   = 7;
  // to clear the interrupt, firmware writes zero (instead of one, usually)
  bool                      ZeroToClear = 8;
}

// InterruptGetRequest is used to query the interrupts on DSC
message InterruptGetRequest {
  // by default only FATAL and ERROR level interrupts are returned
  // All has to be set to true if all interrupts are to be returned
  bool All = 1;
}

// InterruptGetResponse is sent in response to InterruptGetRequest
message InterruptGetResponse {
  // status code to indicated whether the request is successful or not
  types.ApiStatus    ApiStatus = 1;
  // list of interrupts
  repeated Interrupt Interrupt = 2;
}
